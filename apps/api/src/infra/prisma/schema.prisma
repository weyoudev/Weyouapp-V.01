generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(uuid())
  phone         String?        @unique
  email         String?        @unique
  passwordHash  String?
  role          Role
  /** For Branch Head (OPS): the branch they are head of; required when role is OPS. */
  branchId      String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  name          String?
  notes         String?
  isActive      Boolean        @default(true)
  /** Expo push token for mobile app (CUSTOMER). Used to send push when order/subscription/invoice events occur. */
  expoPushToken String?
  addresses     Address[]
  feedback      Feedback[]
  orders        Order[]
  subscriptions Subscription[]
  branch        Branch?        @relation(fields: [branchId], references: [id], onDelete: SetNull)
}

model Address {
  id           String   @id @default(uuid())
  userId       String
  label        String
  addressLine  String
  houseNo      String?
  streetArea   String?
  city         String?
  pincode      String
  isDefault    Boolean  @default(false)
  googleMapUrl String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders       Order[]
  subscriptions Subscription[]
}

model ServiceArea {
  id        String   @id @default(uuid())
  pincode   String   @unique
  branchId  String
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  branch    Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  @@index([branchId])
}

model SlotConfig {
  id         String   @id @default(uuid())
  date       DateTime @db.Date
  timeWindow String
  pincode    String?
  branchId   String?
  capacity   Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([date, timeWindow, pincode])
  @@index([branchId])
}

model Holiday {
  id        String   @id @default(uuid())
  date      DateTime @db.Date
  label     String?
  branchId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, branchId])
  @@index([branchId])
}

model OperatingHours {
  id        String   @id @default(uuid())
  branchId  String?  @unique
  startTime String
  endTime   String
  updatedAt DateTime @updatedAt
}

model ServicePriceConfig {
  id          String      @id @default(uuid())
  serviceType ServiceType @unique
  pricingMode PricingMode
  pricePerKg  Int
  minimumKg   Decimal     @default(3) @db.Decimal(10, 2)
  pickupFee   Int?
  active      Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model DryCleanItem {
  id        String   @id @default(uuid())
  name      String
  unitPrice Int
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Branch {
  id             String   @id @default(uuid())
  name           String
  address        String
  phone          String?
  email          String?
  gstNumber      String?
  panNumber      String?
  footerNote     String?
  logoUrl        String?
  upiId          String?
  upiPayeeName   String?
  upiLink        String?
  upiQrUrl       String?
  isDefault      Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  itemBranches    LaundryItemBranch[]
  orders          Order[]
  planBranches    SubscriptionPlanBranch[]
  subscriptions   Subscription[]
  serviceAreas    ServiceArea[]
  branchHeads     User[]
}

model LaundryItem {
  id              String                   @id @default(uuid())
  name            String                   @unique
  active          Boolean                  @default(true)
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  prices          LaundryItemPrice[]
  orderItems      OrderItem[]
  segmentPrices   ItemSegmentServicePrice[]
  itemBranches    LaundryItemBranch[]
}

model LaundryItemBranch {
  id        String       @id @default(uuid())
  itemId    String
  branchId  String
  createdAt DateTime    @default(now())
  item      LaundryItem  @relation(fields: [itemId], references: [id], onDelete: Cascade)
  branch    Branch       @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([itemId, branchId])
  @@index([branchId])
  @@index([itemId])
}

model ServiceCategory {
  id                    String                   @id @default(uuid())
  code                  String                   @unique
  label                 String
  isActive              Boolean                  @default(true)
  createdAt             DateTime                 @default(now())
  segmentServicePrices  ItemSegmentServicePrice[]
}

model SegmentCategory {
  id                    String                   @id @default(uuid())
  code                  String                   @unique
  label                 String
  isActive              Boolean                  @default(true)
  createdAt             DateTime                 @default(now())
  segmentServicePrices  ItemSegmentServicePrice[]
}

model ItemSegmentServicePrice {
  id                  String          @id @default(uuid())
  itemId              String
  segmentCategoryId   String
  serviceCategoryId  String
  priceRupees         Int
  isActive            Boolean         @default(true)
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  item                LaundryItem     @relation(fields: [itemId], references: [id], onDelete: Cascade)
  serviceCategory     ServiceCategory @relation(fields: [serviceCategoryId], references: [id], onDelete: Cascade)
  segmentCategory     SegmentCategory @relation(fields: [segmentCategoryId], references: [id], onDelete: Cascade)

  @@unique([itemId, segmentCategoryId, serviceCategoryId])
  @@index([itemId])
  @@index([serviceCategoryId])
  @@index([segmentCategoryId])
}

model LaundryItemPrice {
  id             String      @id @default(uuid())
  itemId         String
  serviceType    ServiceType
  unitPricePaise Int
  active         Boolean     @default(true)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  item           LaundryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([itemId, serviceType])
  @@index([itemId])
}

model SubscriptionPlanBranch {
  id        String          @id @default(uuid())
  planId    String
  branchId  String
  createdAt DateTime        @default(now())
  plan      SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
  branch    Branch           @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([planId, branchId])
  @@index([planId])
  @@index([branchId])
}

model SubscriptionPlan {
  id                     String                   @id @default(uuid())
  name                   String
  description            String?                  @db.Text
  redemptionMode         RedemptionMode           @default(MULTI_USE)
  validityDays           Int
  kgLimit                Decimal?                 @db.Decimal(10, 2)
  minKgPerPickup         Decimal?                 @db.Decimal(10, 2)
  applicableServiceTypes String[]
  active                 Boolean                  @default(true)
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  variant                SubscriptionVariant
  maxPickups             Int
  itemsLimit             Int?
  pricePaise             Int
  planBranches           SubscriptionPlanBranch[]
  subscriptions          Subscription[]
}

model Subscription {
  id                 String              @id @default(uuid())
  userId             String
  planId             String
  branchId           String?
  /** Address this subscription is tied to (pincode determines branch). Cannot be changed. */
  addressId          String?
  validityStartDate   DateTime            @default(now())
  remainingPickups   Int
  expiryDate         DateTime
  active             Boolean             @default(true)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  usedKg             Decimal             @default(0) @db.Decimal(10, 2)
  usedItemsCount     Int                 @default(0)
  /** Effective total pickups (plan * quantity at create/extend). Used for limit check; null = use plan.maxPickups. */
  totalMaxPickups    Int?
  /** Effective kg limit (plan.kgLimit * quantity). null = use plan.kgLimit. */
  totalKgLimit       Decimal?            @db.Decimal(10, 2)
  /** Effective items limit (plan.itemsLimit * quantity). null = use plan.itemsLimit. */
  totalItemsLimit    Int?
  orders             Order[]
  plan               SubscriptionPlan    @relation(fields: [planId], references: [id])
  branch             Branch?            @relation(fields: [branchId], references: [id], onDelete: SetNull)
  address            Address?            @relation(fields: [addressId], references: [id], onDelete: SetNull)
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  usages             SubscriptionUsage[]
  payment            Payment?
  invoices           Invoice[]

  @@index([addressId])
}

model SubscriptionUsage {
  id                 String       @id @default(uuid())
  subscriptionId     String
  orderId            String
  invoiceId          String?      // ACK invoice id; when set, enforces one usage per invoice+subscription
  deductedPickups    Int          @default(1)
  createdAt          DateTime     @default(now())
  deductedKg         Decimal      @default(0) @db.Decimal(10, 2)
  deductedItemsCount Int          @default(0)
  order              Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  subscription       Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  invoice            Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@unique([orderId, subscriptionId])
  @@unique([invoiceId, subscriptionId])
  @@index([subscriptionId])
  @@index([orderId])
  @@index([invoiceId])
}

model Order {
  id                String             @id @default(uuid())
  userId            String
  orderType         OrderType          @default(INDIVIDUAL)
  /** When set to WALK_IN, order is from walk-in counter; branch and address are branch-based. */
  orderSource       String?
  serviceType       ServiceType
  serviceTypes      ServiceType[]      @default([])
  addressId         String
  pincode           String
  pickupDate        DateTime
  timeWindow        String
  estimatedWeightKg Decimal?           @db.Decimal(10, 2)
  actualWeightKg    Decimal?           @db.Decimal(10, 2)
  status            OrderStatus
  cancellationReason String?
  cancelledAt       DateTime?
  subscriptionId    String?
  branchId          String?
  paymentStatus     PaymentStatus      @default(PENDING)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  confirmedAt       DateTime?
  pickedUpAt        DateTime?
  inProgressAt      DateTime?
  readyAt           DateTime?
  outForDeliveryAt  DateTime?
  deliveredAt       DateTime?
  feedback          Feedback?
  invoices          Invoice[]
  address           Address            @relation(fields: [addressId], references: [id])
  branch            Branch?            @relation(fields: [branchId], references: [id], onDelete: SetNull)
  subscription      Subscription?      @relation(fields: [subscriptionId], references: [id])
  user              User               @relation(fields: [userId], references: [id])
  orderItems        OrderItem[]
  payment           Payment?
  subscriptionUsages SubscriptionUsage[]

  @@index([userId, createdAt])
  @@index([status, pickupDate])
  @@index([pincode, pickupDate])
  @@index([branchId])
  @@index([orderSource])
}

model Payment {
  id                String          @id @default(uuid())
  orderId           String?         @unique
  subscriptionId    String?         @unique
  provider          PaymentProvider
  status            PaymentStatus
  amount            Int
  providerPaymentId String?
  providerOrderId   String?
  failureReason     String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  order             Order?          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  subscription      Subscription?   @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
}

model OrderItem {
  id                String       @id @default(uuid())
  orderId           String
  laundryItemId     String?
  serviceType       ServiceType
  quantity          Decimal      @db.Decimal(10, 2)
  estimatedWeightKg Decimal?     @db.Decimal(10, 2)
  actualWeightKg    Decimal?     @db.Decimal(10, 2)
  unitPricePaise    Int?
  amountPaise       Int?
  notes             String?
  laundryItem       LaundryItem? @relation(fields: [laundryItemId], references: [id])
  order             Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
}

model Invoice {
  id                     String           @id @default(uuid())
  orderId                String?
  subscriptionId         String?
  code                   String?          // e.g. ACK-20250213-0001-01
  subtotal               Int
  tax                    Int              @default(0)
  total                  Int
  pdfUrl                 String?
  brandingSnapshotJson   Json?
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt
  type                   InvoiceType
  issuedAt               DateTime?
  discountPaise          Int?
  status                 InvoiceStatus
  orderMode              InvoiceOrderMode @default(INDIVIDUAL)
  subscriptionUtilized  Boolean          @default(false)
  subscriptionUsageKg    Decimal?         @db.Decimal(10, 2)
  subscriptionUsageItems Int?
  /** When set, multiple subscriptions used for this order; each gets 1 pickup + weight/items. Array of { subscriptionId }. */
  subscriptionUsagesJson Json?
  paymentStatus          String           @default("DUE")
  paymentOverrideReason  String?
  comments               String?
  /** When set at draft, ACK shows subscription line; subscription is activated only after Final + payment. { planId, planName, validityStartDate, pricePaise, quantityMonths } */
  newSubscriptionSnapshotJson   Json?
  /** When set, new subscriptions from this ACK have been created (after payment). */
  newSubscriptionFulfilledAt    DateTime?
  /** For SUBSCRIPTION type: plan snapshot at purchase { validTill, maxPickups, kgLimit, itemsLimit } for invoice/PDF. */
  subscriptionPurchaseSnapshotJson Json?
  order                          Order?           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  subscription           Subscription?   @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  items                  InvoiceItem[]
  subscriptionUsages     SubscriptionUsage[]

  @@unique([orderId, type])
  // One SUBSCRIPTION invoice per subscription enforced by partial unique index (see migration invoice_subscription_type_partial_unique)
  @@index([orderId])
  @@index([subscriptionId])
}

model InvoiceItem {
  id                 String          @id @default(uuid())
  invoiceId          String
  type               InvoiceItemType
  name               String
  quantity           Decimal         @default(1) @db.Decimal(10, 2)
  unitPrice          Int
  amount             Int
  catalogItemId      String?
  segmentCategoryId  String?
  serviceCategoryId  String?
  createdAt          DateTime        @default(now())
  invoice            Invoice         @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
}

model BrandingSettings {
  id                 String   @id
  businessName       String
  logoUrl            String?
  address            String
  phone              String
  footerNote         String?
  panNumber          String?
  gstNumber          String?
  email              String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  upiId              String?
  upiPayeeName       String?
  upiLink            String?
  upiQrUrl           String?
  termsAndConditions String?
  /** Mobile app privacy policy (editable by super admin only in brand settings). */
  privacyPolicy      String?
  /** Mobile app welcome screen background image (shown at 50% opacity). */
  welcomeBackgroundUrl String?
}

/** Home page carousel: up to 3 images, position 1â€“3. */
model CarouselImage {
  id        String   @id @default(uuid())
  position  Int      @unique
  imageUrl  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Feedback {
  id         String         @id @default(uuid())
  userId     String?
  orderId    String?        @unique
  type       FeedbackType
  rating     Int?
  tags       String[]
  message    String?
  status     FeedbackStatus @default(NEW)
  adminNotes String?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  order      Order?         @relation(fields: [orderId], references: [id])
  user       User?          @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([orderId])
  @@index([status, createdAt])
  @@index([rating])
}

enum Role {
  CUSTOMER
  ADMIN
  OPS
  BILLING
}

enum ServiceType {
  WASH_FOLD
  WASH_IRON
  STEAM_IRON
  DRY_CLEAN
  HOME_LINEN
  SHOES
  ADD_ONS
}

enum OrderStatus {
  BOOKING_CONFIRMED
  PICKUP_SCHEDULED
  PICKED_UP
  IN_PROCESSING
  READY
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELLED
}

enum OrderType {
  INDIVIDUAL
  SUBSCRIPTION
  BOTH
}

enum PricingMode {
  PER_KG
}

enum PaymentProvider {
  RAZORPAY
  CASH
  UPI
  CARD
  NONE
}

enum PaymentStatus {
  PENDING
  CAPTURED
  FAILED
}

enum InvoiceOrderMode {
  INDIVIDUAL
  SUBSCRIPTION_ONLY
  BOTH
}

enum InvoiceType {
  ACKNOWLEDGEMENT
  FINAL
  SUBSCRIPTION
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  VOID
}

enum SubscriptionVariant {
  SINGLE
  COUPLE
  FAMILY
}

enum RedemptionMode {
  MULTI_USE
  SINGLE_USE
}

enum FeedbackType {
  ORDER
  GENERAL
}

enum FeedbackStatus {
  NEW
  REVIEWED
  RESOLVED
}

enum InvoiceItemType {
  SERVICE
  DRYCLEAN_ITEM
  ADDON
  FEE
  DISCOUNT
}
